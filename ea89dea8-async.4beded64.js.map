{"version":3,"sources":["../../node_modules/refractor/lib/core.js"],"sourcesContent":["/**\n * @import {Element, Root, Text} from 'hast'\n * @import {Grammar, Languages} from 'prismjs'\n */\n\n/**\n * @typedef _Token\n *   Hidden Prism token.\n * @property {string} alias\n *   Alias.\n * @property {string} content\n *   Content.\n * @property {number} length\n *   Length.\n * @property {string} type\n *   Type.\n */\n\n/**\n * @typedef _Env\n *   Hidden Prism environment.\n * @property {Record<string, string>} attributes\n *   Attributes.\n * @property {Array<string>} classes\n *   Classes.\n * @property {Array<Element | Text> | Element | Text} content\n *   Content.\n * @property {string} language\n *   Language.\n * @property {string} tag\n *   Tag.\n * @property {string} type\n *   Type.\n */\n\n/**\n * @typedef {((prism: Refractor) => undefined | void) & {aliases?: Array<string> | undefined, displayName: string}} Syntax\n *   Refractor syntax function.\n */\n\n/**\n * @typedef Refractor\n *   Virtual syntax highlighting\n * @property {typeof alias} alias\n * @property {Languages} languages\n * @property {typeof listLanguages} listLanguages\n * @property {typeof highlight} highlight\n * @property {typeof registered} registered\n * @property {typeof register} register\n */\n\n// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.\n// The wrapped non-leaky grammars are loaded instead of Prismâ€™s originals.\nimport {h} from 'hastscript'\nimport {parseEntities} from 'parse-entities'\nimport {Prism} from './prism-core.js'\n\n// Inherit.\nfunction Refractor() {}\n\nRefractor.prototype = Prism\n\n/** @type {Refractor} */\n// @ts-expect-error: TS is wrong.\nexport const refractor = new Refractor()\n\n// Create.\nrefractor.highlight = highlight\nrefractor.register = register\nrefractor.alias = alias\nrefractor.registered = registered\nrefractor.listLanguages = listLanguages\n\n// @ts-expect-error Overwrite Prism.\nrefractor.util.encode = encode\n// @ts-expect-error Overwrite Prism.\nrefractor.Token.stringify = stringify\n\n/**\n * Highlight `value` (code) as `language` (programming language).\n *\n * @param {string} value\n *   Code to highlight.\n * @param {Grammar | string} language\n *   Programming language name, alias, or grammar.\n * @returns {Root}\n *   Node representing highlighted code.\n */\nfunction highlight(value, language) {\n  if (typeof value !== 'string') {\n    throw new TypeError('Expected `string` for `value`, got `' + value + '`')\n  }\n\n  /** @type {Grammar} */\n  let grammar\n  /** @type {string | undefined} */\n  let name\n\n  // `name` is a grammar object.\n  // This was called internally by Prism.js before 1.28.0.\n  /* c8 ignore next 2 */\n  if (language && typeof language === 'object') {\n    grammar = language\n  } else {\n    name = language\n\n    if (typeof name !== 'string') {\n      throw new TypeError('Expected `string` for `name`, got `' + name + '`')\n    }\n\n    if (Object.hasOwn(refractor.languages, name)) {\n      grammar = refractor.languages[name]\n    } else {\n      throw new Error('Unknown language: `' + name + '` is not registered')\n    }\n  }\n\n  return {\n    type: 'root',\n    // @ts-expect-error: we hacked Prism to accept and return the things we want.\n    children: Prism.highlight.call(refractor, value, grammar, name)\n  }\n}\n\n/**\n * Register a syntax.\n *\n * @param {Syntax} syntax\n *   Language function made for refractor, as in, the files in\n *   `refractor/lang/*.js`.\n * @returns {undefined}\n *   Nothing.\n */\nfunction register(syntax) {\n  if (typeof syntax !== 'function' || !syntax.displayName) {\n    throw new Error('Expected `function` for `syntax`, got `' + syntax + '`')\n  }\n\n  // Do not duplicate registrations.\n  if (!Object.hasOwn(refractor.languages, syntax.displayName)) {\n    syntax(refractor)\n  }\n}\n\n/**\n * Register aliases for already registered languages.\n *\n * @param {Record<string, ReadonlyArray<string> | string> | string} language\n *   Language to alias.\n * @param {ReadonlyArray<string> | string | null | undefined} [alias]\n *   Aliases.\n * @returns {undefined}\n *   Nothing.\n */\nfunction alias(language, alias) {\n  const languages = refractor.languages\n  /** @type {Record<string, ReadonlyArray<string> | string>} */\n  let map = {}\n\n  if (typeof language === 'string') {\n    if (alias) {\n      map[language] = alias\n    }\n  } else {\n    map = language\n  }\n\n  /** @type {string} */\n  let key\n\n  for (key in map) {\n    if (Object.hasOwn(map, key)) {\n      const value = map[key]\n      const list = typeof value === 'string' ? [value] : value\n      let index = -1\n\n      while (++index < list.length) {\n        languages[list[index]] = languages[key]\n      }\n    }\n  }\n}\n\n/**\n * Check whether an `alias` or `language` is registered.\n *\n * @param {string} aliasOrLanguage\n *   Language or alias to check.\n * @returns {boolean}\n *   Whether the language is registered.\n */\nfunction registered(aliasOrLanguage) {\n  if (typeof aliasOrLanguage !== 'string') {\n    throw new TypeError(\n      'Expected `string` for `aliasOrLanguage`, got `' + aliasOrLanguage + '`'\n    )\n  }\n\n  return Object.hasOwn(refractor.languages, aliasOrLanguage)\n}\n\n/**\n * List all registered languages (names and aliases).\n *\n * @returns {Array<string>}\n *   List of language names.\n */\nfunction listLanguages() {\n  const languages = refractor.languages\n  /** @type {Array<string>} */\n  const list = []\n  /** @type {string} */\n  let language\n\n  for (language in languages) {\n    if (\n      Object.hasOwn(languages, language) &&\n      typeof languages[language] === 'object'\n    ) {\n      list.push(language)\n    }\n  }\n\n  return list\n}\n\n/**\n * @param {Array<_Token | string> | _Token | string} value\n *   Token to stringify.\n * @param {string} language\n *   Language of the token.\n * @returns {Array<Element | Text> | Element | Text}\n *   Node representing the token.\n */\nfunction stringify(value, language) {\n  if (typeof value === 'string') {\n    return {type: 'text', value}\n  }\n\n  if (Array.isArray(value)) {\n    /** @type {Array<Element | Text>} */\n    const result = []\n    let index = -1\n\n    while (++index < value.length) {\n      if (\n        value[index] !== null &&\n        value[index] !== undefined &&\n        value[index] !== ''\n      ) {\n        // Cast because we assume no sub-arrays.\n        result.push(\n          /** @type {Element | Text} */ (stringify(value[index], language))\n        )\n      }\n    }\n\n    return result\n  }\n\n  /** @type {_Env} */\n  const env = {\n    attributes: {},\n    classes: ['token', value.type],\n    content: stringify(value.content, language),\n    language,\n    tag: 'span',\n    type: value.type\n  }\n\n  if (value.alias) {\n    env.classes.push(\n      ...(typeof value.alias === 'string' ? [value.alias] : value.alias)\n    )\n  }\n\n  // @ts-expect-error Prism.\n  refractor.hooks.run('wrap', env)\n\n  return h(\n    env.tag + '.' + env.classes.join('.'),\n    attributes(env.attributes),\n    env.content\n  )\n}\n\n/**\n * @template {unknown} T\n *   Tokens.\n * @param {T} tokens\n *   Input.\n * @returns {T}\n *   Output, same as input.\n */\nfunction encode(tokens) {\n  return tokens\n}\n\n/**\n * @param {Record<string, string>} record\n *   Attributes.\n * @returns {Record<string, string>}\n *   Attributes.\n */\nfunction attributes(record) {\n  /** @type {string} */\n  let key\n\n  for (key in record) {\n    if (Object.hasOwn(record, key)) {\n      record[key] = parseEntities(record[key])\n    }\n  }\n\n  return record\n}\n"],"names":[],"mappings":"6PAgEa,iDAAA,cAXG,gBACY,gBACR,YAGpB,SAAS,IAAa,CAEtB,EAAU,SAAS,CAAG,OAAK,CAIpB,IAAM,EAAY,IAAI,EAG7B,EAAU,SAAS,CAqBnB,SAAmB,CAAK,CAAE,CAAQ,MAM5B,EAEA,EAPJ,GAAI,AAAiB,UAAjB,OAAO,EACT,MAAM,AAAI,UAAU,uCAAyC,EAAQ,KAWvE,GAAI,GAAY,AAAoB,UAApB,OAAO,EACrB,EAAU,MACL,CAGL,GAAI,AAAgB,UAAhB,MAFJ,CAAA,EAAO,CAAO,EAGZ,MAAM,AAAI,UAAU,sCAAwC,EAAO,KAGrE,GAAI,OAAO,MAAM,CAAC,EAAU,SAAS,CAAE,GACrC,EAAU,EAAU,SAAS,CAAC,EAAK,MAEnC,MAAM,AAAI,MAAM,sBAAwB,EAAO,uBAEnD,CAEA,MAAO,CACL,KAAM,OAEN,SAAU,OAAK,CAAC,SAAS,CAAC,IAAI,CAAC,EAAW,EAAO,EAAS,EAC5D,EACF,EAtDA,EAAU,QAAQ,CAiElB,SAAkB,CAAM,EACtB,GAAI,AAAkB,YAAlB,OAAO,GAAyB,CAAC,EAAO,WAAW,CACrD,MAAM,AAAI,MAAM,0CAA4C,EAAS,KAIlE,OAAO,MAAM,CAAC,EAAU,SAAS,CAAE,EAAO,WAAW,GACxD,EAAO,GAEX,EAzEA,EAAU,KAAK,CAqFf,SAAe,CAAQ,CAAE,CAAK,MAcxB,EAbJ,IAAM,EAAY,EAAU,SAAS,CAEjC,EAAM,CAAC,EAaX,IAAK,IAXD,AAAoB,UAApB,OAAO,EACL,GACF,CAAA,CAAG,CAAC,EAAS,CAAG,CAAI,EAGtB,EAAM,EAMI,EACV,GAAI,OAAO,MAAM,CAAC,EAAK,GAAM,CAC3B,IAAM,EAAQ,CAAG,CAAC,EAAI,CAChB,EAAO,AAAiB,UAAjB,OAAO,EAAqB,CAAC,EAAM,CAAG,EAC/C,EAAQ,GAEZ,KAAO,EAAE,EAAQ,EAAK,MAAM,EAC1B,CAAS,CAAC,CAAI,CAAC,EAAM,CAAC,CAAG,CAAS,CAAC,EAAI,CAE3C,CAEJ,EA/GA,EAAU,UAAU,CAyHpB,SAAoB,CAAe,EACjC,GAAI,AAA2B,UAA3B,OAAO,EACT,MAAM,AAAI,UACR,iDAAmD,EAAkB,KAIzE,OAAO,OAAO,MAAM,CAAC,EAAU,SAAS,CAAE,GAC5C,EAhIA,EAAU,aAAa,CAwIvB,eAKM,EAJJ,IAAM,EAAY,EAAU,SAAS,CAE/B,EAAO,EAAE,CAIf,IAAK,KAAY,EAEb,OAAO,MAAM,CAAC,EAAW,IACzB,AAA+B,UAA/B,OAAO,CAAS,CAAC,EAAS,EAE1B,EAAK,IAAI,CAAC,GAId,OAAO,EACT,EAtJA,EAAU,IAAI,CAAC,MAAM,CA4NrB,SAAgB,CAAM,EACpB,OAAO,EACT,EA5NA,EAAU,KAAK,CAAC,SAAS,CA8JzB,SAAS,EAAU,CAAK,CAAE,CAAQ,EAChC,GAAI,AAAiB,UAAjB,OAAO,EACT,MAAO,CAAC,KAAM,OAAQ,MAAA,CAAK,EAG7B,GAAI,MAAM,OAAO,CAAC,GAAQ,CAExB,IAAM,EAAS,EAAE,CACb,EAAQ,GAEZ,KAAO,EAAE,EAAQ,EAAM,MAAM,EAER,OAAjB,CAAK,CAAC,EAAM,EACZ,AAAiB,KAAA,IAAjB,CAAK,CAAC,EAAM,EACZ,AAAiB,KAAjB,CAAK,CAAC,EAAM,EAGZ,EAAO,IAAI,CACsB,EAAU,CAAK,CAAC,EAAM,CAAE,IAK7D,OAAO,EACT,CAGA,IAAM,EAAM,CACV,WAAY,CAAC,EACb,QAAS,CAAC,QAAS,EAAM,IAAI,CAAC,CAC9B,QAAS,EAAU,EAAM,OAAO,CAAE,GAClC,SAAA,EACA,IAAK,OACL,KAAM,EAAM,IAAI,AAClB,EAWA,OATI,EAAM,KAAK,EACb,EAAI,OAAO,CAAC,IAAI,IACV,AAAuB,UAAvB,OAAO,EAAM,KAAK,CAAgB,CAAC,EAAM,KAAK,CAAC,CAAG,EAAM,KAAK,EAKrE,EAAU,KAAK,CAAC,GAAG,CAAC,OAAQ,GAErB,GAAA,GAAC,EACN,EAAI,GAAG,CAAG,IAAM,EAAI,OAAO,CAAC,IAAI,CAAC,KACjC,AAuBJ,SAAoB,CAAM,EAExB,IAAI,EAEJ,IAAK,KAAO,EACN,OAAO,MAAM,CAAC,EAAQ,IACxB,CAAA,CAAM,CAAC,EAAI,CAAG,GAAA,eAAa,EAAC,CAAM,CAAC,EAAI,CAAA,EAI3C,OAAO,EACT,EAlCe,EAAI,UAAU,EACzB,EAAI,OAAO,EAEf"}